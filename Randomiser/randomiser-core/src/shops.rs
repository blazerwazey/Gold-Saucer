use rand::{rngs::StdRng, Rng, SeedableRng};

use crate::{RandomiserSettings, RandomiserError, Result};

const SHOP_NUM_SHOPS: usize = 80;
const SHOP_RECORD_LEN: usize = 84;
const SHOP_ITEM_MAX: usize = 10;
const SHOP_INVENTORY_POS: usize = 0x521E18;
const HEXT_OFFSET_2: u64 = 0x401600;

struct ShopData {
    shop_type: u16,
    item_count: u8,
    items: Vec<(i32, u16)>,
}

fn decode_shop_record(buf: &[u8; SHOP_RECORD_LEN]) -> ShopData {
    let shop_type = u16::from_le_bytes([buf[0], buf[1]]);
    let item_count = buf[2].min(SHOP_ITEM_MAX as u8);
    let mut items = Vec::new();
    let mut offset = 4usize;
    for _ in 0..item_count {
        if offset + 8 > SHOP_RECORD_LEN {
            break;
        }
        let item_type = i32::from_le_bytes([
            buf[offset],
            buf[offset + 1],
            buf[offset + 2],
            buf[offset + 3],
        ]);
        let index = u16::from_le_bytes([buf[offset + 4], buf[offset + 5]]);
        items.push((item_type, index));
        offset += 8;
    }
    ShopData {
        shop_type,
        item_count: items.len().min(SHOP_ITEM_MAX) as u8,
        items,
    }
}

fn encode_shop_record(shop: &ShopData) -> [u8; SHOP_RECORD_LEN] {
    let mut buf = [0u8; SHOP_RECORD_LEN];
    let ty_bytes = shop.shop_type.to_le_bytes();
    buf[0] = ty_bytes[0];
    buf[1] = ty_bytes[1];
    let count = shop.items.len().min(SHOP_ITEM_MAX);
    buf[2] = count as u8;
    buf[3] = 0;
    let mut offset = 4usize;
    for i in 0..count {
        if offset + 8 > SHOP_RECORD_LEN {
            break;
        }
        let (item_type, index) = shop.items[i];
        let tbytes = item_type.to_le_bytes();
        buf[offset] = tbytes[0];
        buf[offset + 1] = tbytes[1];
        buf[offset + 2] = tbytes[2];
        buf[offset + 3] = tbytes[3];
        let ibytes = index.to_le_bytes();
        buf[offset + 4] = ibytes[0];
        buf[offset + 5] = ibytes[1];
        buf[offset + 6] = 0;
        buf[offset + 7] = 0;
        offset += 8;
    }
    buf
}

fn randomize_shops(shops: &mut [ShopData], settings: &RandomiserSettings) {
    let mut pool: Vec<(i32, u16)> = Vec::new();
    for shop in shops.iter() {
        for &(t, idx) in &shop.items {
            pool.push((t, idx));
        }
    }
    if pool.is_empty() {
        return;
    }
    let mut rng = StdRng::seed_from_u64(settings.seed ^ 0x5A5A_5A5A_u64);
    for shop in shops.iter_mut() {
        for slot in shop.items.iter_mut() {
            let k = rng.gen_range(0..pool.len());
            *slot = pool[k];
        }
    }
}

pub fn build_shops_hext(exe_bytes: &[u8], settings: &RandomiserSettings) -> Result<String> {
    let total_len = SHOP_NUM_SHOPS
        .checked_mul(SHOP_RECORD_LEN)
        .ok_or_else(|| RandomiserError::Config("Shop table size overflow".to_string()))?;
    let start = SHOP_INVENTORY_POS;
    let end = start
        .checked_add(total_len)
        .ok_or_else(|| RandomiserError::Config("Shop table range overflow".to_string()))?;
    if end > exe_bytes.len() {
        return Err(RandomiserError::Config(
            "ff7.exe appears too small to contain shop data at expected offset".to_string(),
        ));
    }

    let mut original_records: Vec<[u8; SHOP_RECORD_LEN]> = Vec::with_capacity(SHOP_NUM_SHOPS);
    let mut shops: Vec<ShopData> = Vec::with_capacity(SHOP_NUM_SHOPS);
    for i in 0..SHOP_NUM_SHOPS {
        let rec_start = start + i * SHOP_RECORD_LEN;
        let rec_end = rec_start + SHOP_RECORD_LEN;
        let mut rec = [0u8; SHOP_RECORD_LEN];
        rec.copy_from_slice(&exe_bytes[rec_start..rec_end]);
        shops.push(decode_shop_record(&rec));
        original_records.push(rec);
    }

    randomize_shops(&mut shops, settings);

    let mut new_records: Vec<[u8; SHOP_RECORD_LEN]> = Vec::with_capacity(SHOP_NUM_SHOPS);
    for shop in &shops {
        new_records.push(encode_shop_record(shop));
    }

    let mut out = String::new();
    out.push_str("..\\ff7.exe\n");
    out.push_str("# English version - generated by FF7 randomiser shop module\n\n");

    for i in 0..SHOP_NUM_SHOPS {
        let old = &original_records[i];
        let new_rec = &new_records[i];
        let mut j = 0usize;
        while j < SHOP_RECORD_LEN {
            if old[j] != new_rec[j] {
                let run_start = j;
                let mut run_bytes: Vec<u8> = Vec::new();
                run_bytes.push(new_rec[j]);
                j += 1;
                while j < SHOP_RECORD_LEN && old[j] != new_rec[j] {
                    run_bytes.push(new_rec[j]);
                    j += 1;
                }
                let pos = SHOP_INVENTORY_POS as u64
                    + HEXT_OFFSET_2
                    + (i * SHOP_RECORD_LEN + run_start) as u64;
                out.push_str(&format!("{:X} = ", pos));
                for b in &run_bytes {
                    out.push_str(&format!("{:02X} ", b));
                }
                out.push('\n');
            } else {
                j += 1;
            }
        }
    }

    Ok(out)
}
